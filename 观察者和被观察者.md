#观察者和被观察者
这一章节比较重要,下面讲的基本就是`Vue`的第一部分核心了,响应式系统。

## 初始化options选项的各个属性

这个初始化主要在`initState`函数中完成的,所以现在去看看这个函数,在`core\instance\state.js`文件中。
```ecmascript 6
export function initState (vm: Component) {
  vm._watchers = [] //设置_watchers为[],作用:用来存放watcher实例的
  const opts = vm.$options //缓存$options(这个时候的$option中的某些属性已经格式化过了)
  if (opts.props/*当前组件的props*/) initProps(vm, opts.props) //父组件传的和子组件想要接收的数据对比,并初始化props
  if (opts.methods) initMethods(vm, opts.methods)//初始化组件的methods
  /*初始化data*/
  if (opts.data) { //存在data初始化组件的data
    initData(vm)
  } else {//没有就添加空对象
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed) //初始化组件的Computed
  //初始化watch(判断vm.$options.watch存在并且不等于(Firefox浏览器中对象原型自带的watch))
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```
   - `_watchers`: 用于收集当前组件实例中的所有观察者实例
   
### initProps
```ecmascript 6
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {} /*父组件传递的props*/
  const props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent //判断是否是根组件
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false) //设置shouldObserve为false
  }
  /*propsOptions在这个时候已经全部转成固定的对象格式了*/
  for (const key in propsOptions) {}//循环子组件接收的想要的通信数据的key(子组件随意订的)
  /*将shouldObserve设置为true,这个值是个开关，表示是否要为值改为观察者属性*/
  toggleObserving(true)
}
```
   - `propsData`: 保存的就是父组件传递下来的数据,合并选项的时候处理过。
    
   - `_props`: 保存的`props`选项最后处理的结果,初始值为空对象
    
   - `_propKeys`: 保存的`props`选项的所有属性名,初始值为空数组

当前组件实例为根组件时,关闭创建观察者实例的开关。然后是循环当前组件实例`$options`选项中的`props`对象,这个对象是已经合并以及规范化过了的。
```ecmascript 6
for (const key in propsOptions) { //循环子组件接收的想要的通信数据的key(子组件随意订的)
    keys.push(key)
    //处理父子组件需要通信的值进行验证处理和默认值处理并输出
    const value = validateProp(key, propsOptions, propsData, vm)
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      //将key解析成kebab-case写法
      const hyphenatedKey = hyphenate(key)
      //与vue保留变量名冲突的键名给予提示
      //是否有与style,class的键名
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      //为props的key属性添加拦截器，改变key值时在非生产环境提示警告
      /*
       提示: 这个报错只出现在修改props中key的值时才会出现,但是如果值是对象或者数组时，当
            你改变的是数组中的某项或这个对象的key值时则不会报这个警告，同时值在父子组件中会同时改变,
            因为对象和数组的引用特性
      */
      defineReactive(props, key, value, () => {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    /*如果key值不在实例上则在实例上为_props添加拦截器并把key添加到_props*/
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
```
首先将属性名放入了`keys`数组变量(也就是`_propKeys`),接下来就是处理属性值了,看到是执行了`validateProp`函数,其参数分别为属性名、
`props`对象、父组件传递下来的数据(`propsData`)、该组件实例本身。那么去看下`validateProp`函数在文件`core\util\props.js`中:

```ecmascript 6
export function validateProp (
  key: string,//子组件props中的key
  propOptions: Object,//子组件的props
  propsData: Object,//父组件传下来的props
  vm?: Component
){
  const prop = propOptions[key] //子组件的prop
  const absent = !hasOwn(propsData, key) //子组件想要的prop父组件是否有传递
  let value = propsData[key] //父组件传递的prop的值
  // boolean casting
  //判断子组件的prop.type是否存在Boolean类型
  const booleanIndex = getTypeIndex(Boolean, prop.type)
  /*当prop.type存在Boolean类型时(这个时候type为数组[Boolean,String])*/
  if (booleanIndex > -1) {
    /*子组件想要的prop父组件没有传递并且子组件的prop没有设置默认值*/
    if (absent && !hasOwn(prop, 'default')) {
      value = false //设置默认值为false
    } else if (value === '' || value === hyphenate(key)) {
      /*父组件传递的prop的值为空或这个值与(将key为驼峰写法时解析成-写法)相同时*/
      //prop设置的默认值和key相同时
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      //判断子组件的prop是否是String类型
      const stringIndex = getTypeIndex(String, prop.type)
      /*不符合String类型或者prop.type中的Boolean类型下标小于String类型时*/
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true
      }
      //总结：(父组件传递的prop的值为空||这个值与key相同时) && type数组为[Boolean,String,...]时
      //默认值设置为true
    }
  }
  // check default value
  //父组件传递的prop的值为undefined并且prop.type不存在Boolean类型
  if (value === undefined) {
    //输出各种情况时的默认值
    value = getPropDefaultValue(vm, prop, key)
    // since the default value is a fresh copy,
    // make sure to observe it.
    const prevShouldObserve = shouldObserve //false
    toggleObserving(true) //设置shouldObserve为true
    observe(value) //为工厂模式函数返回的值生成一个Observer实例，实现响应式
    toggleObserving(prevShouldObserve) //设置shouldObserve为false
  }
  //不为生产环境 && (只要不是weex或者不为对象或者@binding不在父组件传递的prop的值)
  if (
    process.env.NODE_ENV !== 'production' &&
    // skip validation for weex recycle-list child component props
    !(__WEEX__ && isObject(value) && ('@binding' in value))
  ) {
    assertProp(prop, key, value, vm, absent)
  }
  return value
}
```
缓存规范化过的`props`属性值为`prop`变量,忘了的往前翻翻就知道了。判断子组件想要的数据父组件是否有传递,也就是`props`的属性名是否存在于
`propsData`对象中。接着是获取`propsData`对象中的该属性值为`value`变量，然后是执行`getTypeIndex`函数,参数为`Boolean`类型和子组件想要的
这个属性指定的类型,最后将值赋值给`booleanIndex`变量,在这里就不多讲这个函数了,直接将作用吧。

   - `booleanIndex`: 这个函数字面意思很好理解,就是确定是否指定了`Boolean`类型以及获取`Boolean`类型在该属性指定类型中的下标,其作用
                     也确实是这个.存在返回下标,不存在范回`-1`

不存在指定`Boolean`类型,跳过;存在,进入语句块后又出现了2种情况:
    
   1、父组件没有传递这个属性值&&`prop`变量(也就是子组件想要的属性值)没有设置默认值: 设置`value`变量为`false`,也就是设置最后的传递的值
      为`false`                    

   2、`value`变量为空字符串(传递了值但是个空字符串) || `value`变量全等于转化为`kebab-case`写法的属性名: 不存在指定`String`类型或者
      存在指定`String`类型但是指定`Boolean`类型在前,设置`value`变量为`true`。例子: 
      
```ecmascript 6
propsData = {
    str: ''
}
props: {
    str: {
        type: [Boolean,String]
    }
}
// 处理后
str = true
```        
然后是对`value`变量为`undefined`的处理,那怎么才会出现这个情况呢?根据上面的处理可以分析出以下情况会出现`value`变量为`undefined`:

   1、指定类型中没有`Boolean`类型&&父组件没有传递子组件需要的属性值
   
   2、指定类型中有`Boolean`类型&&父组件传递了(不为空字符串 && 不为转化为`kebab-case`写法的属性名)的值         

   3、指定类型中有`Boolean`类型 && 父组件没有传递值 && 子组件设置了默认值 

   4、指定类型为`[String,Boolean]`类型 && 父组件传递了(空字符串 || 转化为`kebab-case`写法的属性名)

当`value`变量为`undefined`时,会做一下几步:

   1、执行`getPropDefaultValue`函数,作用: 获取子组件设置的默认值,不存在返回`undefined`;存在则返回默认值.如果默认值为对象或数组时,
                                          需要提示用户对象或数组必须使用函数的形式输出。  

   2、缓存原先的创建观察者实例开关情况,开启创建观察者实例的开关 

   3、当值为对象或数组时以深遍历的方式对对象和数组分别处理(这个后面也会具体讲):
        
       数组: 添加值为观察者实例的不可枚举属性`__ob__`,循环数组对值为数组或对象的项进行分别处理
        
       对象: 添加值为观察者实例的不可枚举属性`__ob__`,循环对象,为属性重写描述符(也就是添加拦截器),当值为对象或数组时进行分别处理

   4、将创建观察者实例开关还原成原先的情况 

`validateProp`函数最后一段代码是在生产环境对`prop`值的验证: 

   - 子组件的单个`prop`中设置了`required`属性,表示父组件必须传值,但父组件又没传值时,提示警告信息'缺少必需的`prop`',并结束函数
   
   - 最后处理完的`value`值为`undefined` && `prop`没有设置`required`属性,结束函数
   
   - 处理完的`value`值与指定的值类型不符时,提示错误信息'`prop`类型检测失败,与所需不符'

   - 子组件的单个`prop`中设置了`validator`属性,表示自定义验证函数,当自定义函数对传递的值验证不符时(也就是函数没有返回值或返回了`false`)
     时提示警告信息'自定义验证器检查`prop`失败'


`validateProp`函数总结: 对父组件未传值或传了值以及子组件设置了默认值和未设置默认值进行处理,然后对处理的值进行指定类型验证或自定义函数验证,对不符合类型的值
提示不同的警告信息,最后把处理完的`value`值输出.

继续回到`initProps`函数中来,这个时候已经获取处理完的`prop`值了并缓存为变量`value`.然后在生产环境和非生产环境下都为实例的`_props`
属性重写了描述符(相当于添加了拦截器),但在非生产环境下会对`props`属性名进行检测,如果与`key`,`ref`,`slot`,`slot-scope`,`is`,
`style`,`class`的键名冲突时提示警告信息'属性名是保留属性,不能用作子组件接收`prop`'.当修改`_props`的属性值时提示'避免修改`_props`
属性数据,当父组件重新渲染时,修改的值又将被覆盖'。最后是将`_props`的属性添加到实例上,并为实例的该属性添加重写描述符,当读取实例的该属性
值时,相当于读取`_props`的该属性值

### initMethods





