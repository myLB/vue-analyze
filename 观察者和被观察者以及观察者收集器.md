#观察者和被观察者以及收集器
这一章节比较重要,下面讲的基本就是`Vue`的第一部分核心了,响应式系统。

## 收集器
因为在观察者和被观察者中都用到了所以先将这个.其实收集器它其实一个实例,观察者创建的收集器实例那就是被观察者收集器;被观察者创建的收集器
实例那就是观察者收集器。
```ecmascript 6
export default class Dep {
  static target: ?Watcher;//只有在创建Watcher实例并且不为计算属性的时候target才会存在值
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }
  //读取属性时，会执行这个方法.这个就是收集依赖也就是收集watcher实例
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```
这个就是一个`Dep`类,我称它的实例为收集器。首先来看下当创建实例时,其会初始化`2`个实例属性`id`和`subs`,`id`就是表示这个收集器的标识符,
而`subs`数组就是关键的这个收集器,里面保存的都是观察者或被观察者。那么怎么收集的? 我不要观察者或被观察者时怎么去掉呢？所以其另外的四个
实例函数就是用来处理这些的。

   - `addSub`: 这个函数就是用来往`subs`数组添加观察者或被观察者的
   
   - `removeSub`: 这个函数就是将观察者或被观察者从收集器中删除的
   
   - `depend`: 这个函数是用于当前执行观察者实例的`addDep`函数的,参数是收集器实例,具体等讲到观察者实例的时候在讲
   
   - `notify`: 这个函数是用于执行收集到的所有观察者实例的`update`函数的,也是等讲到观察者实例的时候在讲


## 被观察者
讲到被观察者实例在上一章节中我们在三个地方谈到了,一个是初始化`props`和`inject`的时候,一个是初始化`data`的时候。只不过在初始化
`props`和`inject`的时候是把创建被观察者关闭了,那么为什么呢？现在就来讲一下为什么以及在`props`和`inject`遗留下来的`defineReactive`
函数.

### defineReactive
```ecmascript 6
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()
  //获取指定对象的自身属性描述符
  const property = Object.getOwnPropertyDescriptor(obj, key)
  /*Configurable:表示能否通过delete删除属性从而重新定义属性；
    Enumerable：表示能否通过for-in循环返回属性
    writable：表示能否修改属性的值
    Value：包含这个属性的数据值（个人认为其作用就是赋值）
  */
  //该属性的描述对象存在并且该属性不能删除或重新定义直接return
  if (property && property.configurable === false) {
    return
  }
  //以下是在对象不存在该属性 或者 存在但是可以删除的
  // cater for pre-defined getter/setters
  const getter = property && property.get //存在则读取默认get
  const setter = property && property.set //存在则读取默认set
  /*
    1、arguments.length === 2,这个很好判断，只是为了让有些情况下执行这个方法的时候可以满足，以便于深度遍历(相当于为了兼容)
    2、!getter || setter， 这句代码是没有get函数,也就是用户没用自定义过属性的get函数，那么就需要深度观测数据.
      还有种用户即定义了get也定义了set函数，那么也需要深度观测数据，而后面又重写了get和set函数，在设置新值的时候观测数据,
      如果没有 || setter会造成初始化的时候没有观测数据，可是在重新赋值过后又观测数据了，从而造成定义响应式数据时行为的不一致。
  */
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }
  //值为对象或数组则创建一个Observer实例
  let childOb = !shallow && observe(val)
  //直接定义属性或修改这个对象的这个属性
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      //如果存在get就直接读取对象中的值，否则读取参数值val
      const value = getter ? getter.call(obj) : val
      //存在watcher实例
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          //如果是数组就深度遍历并存储这个watcher实例
          /*
            为什么数组要这么做?
              arr: [
                { a: 1 }
              ]
              比如: <div id="demo">
                      {{arr}}
                    </div>
              这个时候只读取了arr并没有读取arr里面的项,也就是只有arr中的dep属性收集到了依赖而arr[0]并没有收集到依赖，
              因为没有读取过，所以就造成了修改了数据也没有响应式，常常发现打印出的数据变化了但是页面怎么没变化(vue1中和vue2初期经常会出现)
          */
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    /*
      设置属性时先执行dep.notify(),在dep.notify()中执行各个watcher实例的update(),
      update()中执行queueWatcher(),queueWatcher()中先将watcher实例放入queue数组中,
      在执行nextTick(),在nextTick方法中将flushSchedulerQueue函数放入callbacks数组中,
      并执行microTimerFunc(),microTimerFunc()中执行Promise的then函数这个函数会等
      所有同步任务执行完后再执行,那么这个时候将会等各个watcher实例的update()执行完后，
      也就是将所有的所有watcher实例放入queue数组中,然后这个时候所有的同步任务已执行完了,
      然后执行then函数中的flushCallbacks函数,这个函数中将会把callbacks数组中的所有函数执行,
      那么就是执行flushSchedulerQueue函数,这个函数会依次执行queue数组中watcher的run函数,
      run函数中执行getAndInvoke(),getAndInvoke()中执行get(),get()中会设置Dep.target为当前
      watcher实例,并执行getter(),getter()的执行会引发读取的该属性的get(),从而上面get函数中的
      if (Dep.target)判断成立,触发判断中的方法,最后将Dep.target设置为undefined,清空改实例中的
      依赖收集,在回到getAndInvoke函数中执行后续的步骤,执行完成
    */
    set: function reactiveSetter (newVal) {
      //读取oldVal
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      /*值没变化直接return*/
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      //set存在更新新值否则将新值赋值旧值
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal) //新值为对象或数组则创建一个Observer实例
      dep.notify() //值更新告诉所有订阅这个变量的更新视图
    }
  })
}
```
首先是创建了一个私有的观察者收集器`Dep`实例,也就是跳出这函数之后拿不到的。然后接下来是对一些其他地方调用该函数的一些兼容,这里可以暂时
忽略.主要讲的是`!shallow && observe(val)`函数,其中`shallow`这个参数在`props`和`inject`初始化中都没传,所以一定会执行后面的`observe`
函数,这个函数就是用来处理对什么样的数据生成观察者实例的,这里可以先不讲,因为在初始化`data`的时候也执行了这个函数,参数也是属性值。接下来
是为属性重写描述符,主要的就是`get`和`set`这两个函数:

   - get: 当读取该属性时,缓存当前属性的最新属性值,接着是判断当前观察者实例是否存在,那么什么时候观察者实例存在呢？这个疑问到将观察者实例
          的时候在揭秘。现在就假设有,那么其就会执行收集器实例的`depend`函数,这个函数提到过是用来执行观察者实例的`addDep`函数的。接着
          是判断被观察者实例是否存在,在存在的情况下执行被观察者实例的`dep`属性的`depend`函数,其实也就是被观察者内部的收集器中的
          `depend`函数。最后如果属性值是数组的话,深遍历数组,执行其项值中存在的被观察者实例的`dep`属性的`depend`函数。最后返回最新的
          属性值
            
   - set: 当设置该属性值时,首先缓存旧值,如果新值和旧值没有改变时,终止该函数.然后是将旧值替换为新值,在为新值创建一个被观察者实例,接着是
          执行私有观察者收集器`Dep`实例中的`notify`函数,也就是执行所有这个被观察的数据中收集的观察者实例的`update`函数  


### observe
```ecmascript 6
export function observe (value: any, asRootData: ?boolean){
  /*值不为(对象/数组)或者值是否为VNode的实例*/
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  /*值存在'__ob__'并且value.__ob__ 为 Observer的实例*/
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    /*
      shouldObserve为true && 不为服务端
      && (值为对象或者数组) && 对象可以被拓展 && 值的_isVue不为true
    */
    ob = new Observer(value)
  }
  //为根组件数据并且存在已经是Observer实例时
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
```
可以看到如果属性值不为对象时或者为虚拟节点实例时将不会创建被观察者实例。如果本身已经存在就不用添加被观察者实例了,还有一种就是控制开关
手动关闭了的,也就是`props`和`inject`,最后一种就是如果函数传入的参数是`Vue`实例时也是不会生成被观察者实例的。最后是当`asRootData`
参数为`true`时会为被观察者实例的标识符`+1`,这个只有才初始化`data`的时候传了,那么就说明只有组件的`data`数据的被观察者实例的标识符才是
唯一的,这里可以提前说就是`vmCount`为`1`。

### Observer类(被观察者)
```ecmascript 6
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    //为值添加一个__ob__属性并且不能枚举的描述符
    def(value, '__ob__', this)
    //判断是否是数组
    if (Array.isArray(value)) {
      const augment = hasProto //当前环境是否支持 __proto__ 属性
        ? protoAugment
        : copyAugment
      //为数组的一些默认方法添加拦截
      augment(value, arrayMethods, arrayKeys)
      /*递归为数组添加拦截器*/
      this.observeArray(value)
    } else {
      /*为对象添加拦截器*/
      this.walk(value)
    }
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  /*深遍历对象，为对象中的对象或数组添加拦截器*/
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  /*深遍历数组,为数组中的数组或对象添加拦截器*/
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}
```
为属性值添加了不能枚举属性`__ob__`为创建的被观察者实例

   - `value`: 被观察者属性的属性值
   
   - `dep`: 被观察者实例内部的观察者收集器
   
   - `vmCount`: 被观察者拜实例标识符,只有组件的`data`数据才是`1`,其它都是`0`(包括data对象中值是对象的属性)

   - `walk`: 这个函数是循环对象属性执行`defineReactive`函数,作用不用多说就是为属性重写描述符以及为对象的属性值添加被观察者实例。 

   - `observeArray`: 这个是循环数组执行`observe`函数,也就是为数组各项添加被观察者实例。 


到这里我们就来说说关闭那个创建被观察者实例的开关,对`props`(非根组件的`props`)和`inject`造成了什么.当`props`(非根组件的`props`)和
`inject`中的属性值为数组或对象时,不会为其值添加观察者实例和其值的属性重写描述符,并且只有当子组件取的是默认值时才会这样.因为不是默认的,
父组件就已经为其添加过观察者实例和重写过描述符(也就是拦截器)了,没必要多此一举了。这个从中说明一个问题,`Vue`希望数据只能在一个地方改变,
谁传下来的只能在谁那里改变。保证数据的只能单向改变.同时当这种情况下,属性值对象中的某一个属性的值改变时,并不会刷新视图。


## 观察者
观察者在`2`个地方被创建了,一个是`computed`另一个是`watch`.`computed`是一个计算属性创建一个观察者实例,而`watch`是一个监听函数就是
一个观察者实例。

```ecmascript 6
export default class Watcher {
  constructor (
    vm: Component, //组件实例对象 vm
    expOrFn: string | Function, //要观察的表达式 expOrFn
    cb: Function, //当被观察的表达式的值变化时的回调函数 cb
    options?: ?Object, //一些传递给当前观察者对象的选项 option
    isRenderWatcher?: boolean //用来标识该观察者实例是否是渲染函数的观察者
  ) {
    this.vm = vm
    /*
      把vm._watcher赋值为这个实例
        1、computed不会
        2、watch不会
        3、初始渲染组件时会
    */
    if (isRenderWatcher) {
      //将watch实例赋值给Vue实例的_watcher属性
      vm._watcher = this
    }
    //往vm._watcher添加这个实例
    vm._watchers.push(this)
    /*1、computed:{
          computed: true
         }
      2、watch: {
          handler: function (val, oldVal) { /!* ... *!/ },
          deep: true,
          immediate: true
         }
      3、mounted: {
          before () {
            if (vm._isMounted) {
              callHook(vm, 'beforeUpdate')
            }
          }
        }
    */
    if (options) {
      this.deep = !!options.deep //是否深度监听(用于watch的数组)
      this.user = !!options.user //标识当前观察者实例对象是 开发者定义的 还是 内部定义的
      this.computed = !!options.computed //是否是计算属性
      this.sync = !!options.sync //父子组件传递数据时是否存在.sync
      this.before = options.before //这个初始化挂载组件的时候传递的参数
    } else {
      this.deep = this.user = this.computed = this.sync = false
    }
    this.cb = cb //回调
    this.id = ++uid // uid for batching
    this.active = true //标识着该观察者实例对象是否是激活状态
    this.dirty = this.computed // true:当前观察者对象没有被求值
    /*
      1、newDepIds 属性用来在一次求值中避免收集重复的观察者
      2、每次求值并收集观察者完成之后会清空 newDepIds 和 newDeps 这两个属性的值，
        并且在被清空之前把值分别赋给了 depIds 属性和 deps 属性
      3、depIds 属性用来避免重复求值时收集重复的观察者
    */
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString() //将表达式转换成字符串
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)//解析表达式或字符串并返回一个(方法或undefined)
      /*返回undefined报错*/
      if (!this.getter) {
        this.getter = function () {}
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    //计算属性的watcher实例中的value属性为undefined否则值为this.getter表达式输出的值
    if (this.computed) {
      this.value = undefined
      this.dep = new Dep()
    } else {
      //执行this.get()并将返回值赋值给this.value
      this.value = this.get()
    }
  }
}
```
其还有很多共有函数,这个下面会一一讲,现在先来看下当创建观察者实例时都干了什么！

   - `vm`: 当前组件实例,实例的`_watcher`属性为观察者实例(这个是渲染函数创建观察者实例才有的属性,简称渲染函数观察者实例),实例的
           `_watchers`属性中将观察者实例放入该数组中,这个前面提到过该属性的作用.
   
   - `deep`: 用于是否深度监听某个数据的变化 

   - `user`: 这个在使用`$watch`这个`api`时`Vue`内部自动加的,表示开发者手动创建的。
   
   - `computed`: 这个很好理解,表示是计算属性创建的观察者实例














